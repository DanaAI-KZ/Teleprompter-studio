<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Teleprompter Studio</title>
<link rel="icon" type="image/png" href="logo.png">
<style>
    :root { 
        --bg-panel: #1a1a1c; 
        --accent: #007bff; 
        --success: #28a745; 
        --danger: #dc3545; 
        --warning: #ff9800; 
        --stat-color: #00ff88; 
        --text-muted: #888; 
    }
    
    body { margin:0; font-family:'Inter',-apple-system,sans-serif; background:black; color:#e0e0e0; overflow:hidden; }
    
    #controls { 
        position:fixed; top:0; width:100%; background: var(--bg-panel); 
        padding:12px 20px; display:flex; gap:20px; align-items:center; 
        z-index:1000; border-bottom:1px solid #333; box-sizing:border-box; 
    }
    
    .input-section { flex: 2; }
    textarea { width:100%; height:60px; background:#252527; color:#fff; border:1px solid #444; padding:10px; font-size:14px; resize:none; border-radius:8px; outline:none; transition: 0.3s; }
    textarea:disabled { opacity:0.3; background:#111; border-color: #222; }

    .stat-display { display:flex; gap:15px; background:#000; padding:8px 15px; border-radius:8px; border:1px solid #333; min-width:250px; }
    .stat-group { display:flex; flex-direction:column; }
    .stat-label { color:var(--text-muted); font-size:9px; text-transform:uppercase; font-weight:bold; }
    .stat-item { font-size:16px; color:var(--stat-color); font-family:monospace; font-weight:bold; }

    .sliders-box { display:flex; flex-direction:column; gap:5px; min-width:160px; }
    .slider-row { display:flex; align-items:center; gap:8px; }
    .slider-row label { font-size:9px; color:var(--text-muted); width:45px; text-transform:uppercase; }
    input[type=range] { flex:1; accent-color: var(--accent); cursor:pointer; }
    input[type=range]:disabled { opacity: 0.2; cursor: default; }

    .actions { display:flex; gap:8px; }
    button { padding:10px 14px; cursor:pointer; background:#333; color:white; border:none; border-radius:6px; font-size:10px; font-weight:700; text-transform:uppercase; transition:0.2s; outline:none; }
    button:disabled { opacity: 0.3 !important; cursor: default !important; box-shadow: none !important; }
    
    #startBtn { background: var(--success); min-width:90px; }
    #startBtn.active { background: var(--danger); }
    #mirrorBtn.active { background: var(--warning) !important; color:#000; }
    #openWindowBtn.active { background: var(--accent) !important; box-shadow: 0 0 15px rgba(0,123,255,0.4); }

    /* PERF button styles */
    #perfBtn { min-width:100px; }
    #perfBtn.mode0 { background:#333; }
    #perfBtn.mode1 { background: var(--warning); color:#000; }
    #perfBtn.mode2 { background: var(--danger); }

    .view-container { position:relative; width:100%; height:100vh; display:flex; justify-content:center; overflow:hidden; }

    /* базовое качество (по умолчанию) */
    #text-display { 
        position:absolute; text-align:center; line-height:1.5; 
        white-space:pre-wrap; word-wrap:break-word; top:0; 
        will-change: transform; transform: translate3d(0,0,0);
        backface-visibility:hidden; text-rendering: auto; -webkit-font-smoothing: antialiased;
    }

    /* Wrapper для отдельного зеркалирования без пересборки transform-строки */
    #mirror-wrap {
        position:absolute;
        top:0; left:0; right:0; bottom:0;
        display:flex;
        justify-content:center;
        pointer-events:none;
    }
    #mirror-wrap.mirror { transform: scaleX(-1); }

    /* PERFORMANCE MODE (включается только тумблером) */
    body.perf #text-display {
        contain: layout paint;
        will-change: auto;
        -webkit-font-smoothing: auto;
    }

    .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(12px); z-index: 2000; justify-content: center; align-items: center; }
    .modal-card { background: #1e1e20; width: 480px; height: 580px; border-radius: 28px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 30px 60px rgba(0,0,0,0.6); }
    
    .modal-tabs { display: flex; background: #252527; flex-shrink: 0; }
    .tab-btn { flex: 1; padding: 16px; border: none; background: transparent; color: #666; font-weight: bold; cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; transition: 0.3s; }
    .tab-btn.active { color: var(--accent); background: #1e1e20; border-bottom: 2px solid var(--accent); }
    
    .tab-content { padding: 35px 40px; display: none; flex-direction: column; align-items: center; flex-grow: 1; overflow: hidden; box-sizing: border-box; }
    .tab-content.active { display: flex; }

    .program-title { font-size: 24px; font-weight: 900; color: #fff; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .program-version { font-size: 12px; color: var(--stat-color); font-family: monospace; font-weight: 700; margin-bottom: 14px; letter-spacing: 0.5px; }
    .program-desc { font-size: 15px; line-height: 1.5; color: #ddd; margin-bottom: 25px; text-align: center; }
    
    .help-grid { display: flex; flex-direction: column; gap: 10px; width: 100%; margin-bottom: 25px; }
    .help-row { display: flex; justify-content: space-between; font-size: 14px; border-bottom: 1px solid #2a2a2c; padding-bottom: 8px; align-items: center; }
    .key-cap { background: #333; padding: 4px 12px; border-radius: 6px; color: var(--stat-color); font-family: monospace; font-weight: bold; border: 1px solid #444; font-size: 13px; }

    .logo-img { width: 180px; height: 180px; margin-bottom: 15px; filter: drop-shadow(0 0 25px rgba(0,123,255,0.25)); object-fit: contain; }
    .author-name { font-size: 22px; font-weight: 600; color: #fff; margin-bottom: 4px; }
    .ceo-label { font-size: 14px; color: var(--accent); font-weight: 700; margin-bottom: 12px; }
    .connect-link { color: #ccc; text-decoration: none; font-size: 14px; transition: 0.3s; font-weight: 500; display: block; margin-bottom: 8px; }
    .connect-link:hover { color: var(--accent); }

    .copyright { font-size: 9px; color: var(--warning); text-transform: uppercase; letter-spacing: 1.2px; border-top: 1px solid #333; padding-top: 20px; width: 100%; font-weight: 700; text-align: center; margin-top: auto; }
    .close-btn { background: #2a2a2c; color: #fff; width: 100%; padding: 20px; border: none; border-top: 1px solid #333; font-weight: 900; cursor: pointer; text-transform: uppercase; font-size: 13px; transition: 0.2s; flex-shrink: 0; }
    .close-btn:hover { color: var(--danger); background: #333; }

    .reading-marker {
        position: fixed;
        top: 50%;
        left: 0;
        width: 48px;
        height: 0;
        border-top: 2px solid var(--danger);
        z-index: 900;
        pointer-events: none;
        transform: translateY(-50%);
    }

    .reading-marker::before {
        content: "";
        position: absolute;
        right: 0;
        top: -6px;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
        border-left: 10px solid var(--danger);
    }
</style>
</head>
<body>

<div id="controls">
    <div class="input-section"><textarea id="input" placeholder="Введите ваш текст..."></textarea></div>
    <div class="stat-display">
        <div class="stat-group"><span class="stat-label">Скорость</span><span id="speedVal" class="stat-item">5</span></div>
        <div class="stat-group"><span class="stat-label">Шрифт</span><span id="fontVal" class="stat-item">60</span></div>
        <div class="stat-group"><span class="stat-label">Ширина</span><span id="widthVal" class="stat-item">80%</span></div>
    </div>
    <div class="sliders-box">
        <div class="slider-row"><label>Скорость</label><input type="range" id="speedSlider" min="0" max="40" value="5"></div>
        <div class="slider-row"><label>Шрифт</label><input type="range" id="fontSlider" min="20" max="200" value="60"></div>
        <div class="slider-row"><label>Ширина</label><input type="range" id="widthSlider" min="20" max="100" value="80"></div>
    </div>
    <div class="actions">
        <button id="startBtn">СТАРТ</button>
        <button id="mirrorBtn">ЗЕРКАЛО</button>
        <button id="openWindowBtn">ОКНО ДИКТОРА</button>
        <button id="markerBtn">МАРКЕР</button>
        <button id="perfBtn">QUALITY</button>
        <button id="aboutBtn">INFO</button>
    </div>
</div>

<div id="readingMarker" class="reading-marker" aria-hidden="true"></div>

<div id="aboutModal" class="modal-overlay">
    <div class="modal-card">
        <div class="modal-tabs">
            <button class="tab-btn active" onclick="showTab('tab-help', this)">О программе</button>
            <button class="tab-btn" onclick="showTab('tab-author', this)">Об авторе</button>
        </div>
        
        <div id="tab-help" class="tab-content active">
            <div class="program-title">Teleprompter Studio</div>
            <div class="program-version" id="versionInfoA">v?.?.?</div>
            <div class="program-desc">
                Современный веб-суфлер с поддержкой двухэкранного режима. 
                Зеркальный режим гарантирует совместимость с профессиональным оборудованием.
            </div>
            <div class="help-grid">
                <div class="help-row"><span>Старт / Пауза</span><span class="key-cap">Space</span></div>
                <div class="help-row"><span>Скорость</span><span class="key-cap">↑ / ↓</span></div>
                <div class="help-row"><span>Шрифт / Ширина (пауза)</span><span class="key-cap">Стрелки</span></div>
                <div class="help-row"><span>Прокрутка вручную (пауза)</span><span class="key-cap">Wheel</span></div>
                <div class="help-row"><span>В начало</span><span class="key-cap">Home</span></div>
                <div class="help-row"><span>Режим производительности</span><span class="key-cap">P</span></div>
            </div>
            <div class="copyright">© 2026 DANA SYSTEMS. SYSTEMS THAT THINK.</div>
        </div>

        <div id="tab-author" class="tab-content">
            <img src="logo.png" class="logo-img" alt="Logo">
            <div style="font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px;">Created by</div>
            <div class="author-name">Nurlan Akkainanov</div>
            <div class="ceo-label">CEO, Dana Systems</div>
            <div class="program-version" id="versionInfoB">v?.?.?</div>
            <div class="connect-section" style="text-align: center;">
                <a href="https://t.me/NurlanDS" target="_blank" class="connect-link">Telegram: @NurlanDS</a>
                <a href="https://www.dana-systems.com" target="_blank" class="connect-link">Web: www.dana-systems.com</a>
            </div>
            <div class="copyright">© 2026 DANA SYSTEMS. SYSTEMS THAT THINK.</div>
        </div>
        <button class="close-btn" id="closeAboutBtn">ЗАКРЫТЬ</button>
    </div>
</div>

<div class="view-container">
    <div id="mirror-wrap">
        <div id="text-display"></div>
    </div>
</div>

<script>
// =================== VERSION ===================
const APP_VERSION = "v1.0.8"; // <-- меняй тут
try {
  document.title = `Teleprompter Studio ${APP_VERSION}`;
} catch(_) {}
// ==============================================

const channel = new BroadcastChannel('tele_v24_broadcast');
const params = new URLSearchParams(window.location.search);
const isPrompter = params.get('mode') === 'prompter';

const textDisplay = document.getElementById('text-display');
const mirrorWrap = document.getElementById('mirror-wrap');
const inputArea = document.getElementById('input');
const speedSlider = document.getElementById('speedSlider');
const fontSlider = document.getElementById('fontSlider');
const widthSlider = document.getElementById('widthSlider');
const startBtn = document.getElementById('startBtn');
const openWindowBtn = document.getElementById('openWindowBtn');
const mirrorBtn = document.getElementById('mirrorBtn');
const markerBtn = document.getElementById('markerBtn');
const perfBtn = document.getElementById('perfBtn');
const readingMarker = document.getElementById('readingMarker');

const versionInfoA = document.getElementById('versionInfoA');
const versionInfoB = document.getElementById('versionInfoB');
if (versionInfoA) versionInfoA.innerText = APP_VERSION;
if (versionInfoB) versionInfoB.innerText = APP_VERSION;

let prompterWindow = null;
let lastTime = performance.now();
let smoothSpeed = 0;
let needRecalc = true;
const cache = { text: '', fontSize: 0, width: 0 };
let distance = 0;

// ======= NEW: prompter smoothing (interpolation) =======
let targetProgress = 0;
let displayProgress = 0;
// =======================================================

// PERF runtime config
const perf = {
  mode: 0,                 // 0 quality, 1 balanced, 2 performance
  targetFps: 60,
  frameMs: 1000 / 60,
  lastFrame: 0,
  progressIntervalMs: 16   // QUALITY smooth by default (60fps IPC)
};

// ---- Save (debounced) ----
const STORAGE_KEY = 'tele_v24_settings';
let saveTimer = null;
function saveStateDebounced() {
    if (isPrompter) return;
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify({
                text: state.text,
                speed: state.speed,
                fontSize: state.fontSize,
                width: state.width,
                mirror: state.mirror,
                winX: state.winX, winY: state.winY, winW: state.winW, winH: state.winH,
                markerEnabled: state.markerEnabled,
                perfMode: state.perfMode
            }));
        } catch(_) {}
    }, 350);
}

const saved = (() => {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
    catch { return {}; }
})();

let state = {
    text: saved.text || "Введите ваш текст здесь...",
    speed: saved.speed || 5,
    fontSize: saved.fontSize || 60,
    width: saved.width || 80,
    progress: 0,
    scrolling: false,
    mirror: saved.mirror || false,
    winX: saved.winX || 100,
    winY: saved.winY || 100,
    winW: saved.winW || 800,
    winH: saved.winH || 600,
    markerEnabled: saved.markerEnabled || false,
    perfMode: (typeof saved.perfMode === 'number') ? saved.perfMode : 0
};

// init smoothing vars from state
targetProgress = state.progress;
displayProgress = state.progress;

// ---- Sync logic ----
function syncFull() { channel.postMessage({ type: 'SYNC', data: state }); }
function sendProgress(progress) { channel.postMessage({ type: 'PROGRESS', progress }); }
function clearFocus() { if (document.activeElement) document.activeElement.blur(); }

channel.onmessage = (e) => {
    const msg = e.data || {};

    if (msg.type === 'SYNC') {
        state = msg.data;
        needRecalc = true;
        applyPerfMode(false);

        // NEW: reset interpolation baseline to avoid jump
        targetProgress = state.progress;
        displayProgress = state.progress;

        updateUI();
    }

    if (msg.type === 'PROGRESS') {
        // NEW: don't assign state.progress directly -> prevents stepping in prompter
        targetProgress = msg.progress;
        // update only fast (position), controller will still render its own smoothness
        if (isPrompter) updateUI(true);
    }

    if (msg.type === 'REQ' && !isPrompter) syncFull();
};

// ---- Layout recalculation ----
function recalcDistance() {
    distance = textDisplay.scrollHeight + window.innerHeight;
    needRecalc = false;
}
window.addEventListener('resize', () => { needRecalc = true; });

// ---- PERF helpers ----
function perfLabel(mode) {
  return mode === 0 ? 'QUALITY' : mode === 1 ? 'BALANCED' : 'PERF';
}

function applyPerfMode(shouldSync = true) {
  state.perfMode = (state.perfMode === 0 || state.perfMode === 1 || state.perfMode === 2) ? state.perfMode : 0;
  perf.mode = state.perfMode;

  // smooth defaults: QUALITY/BALANCED -> frequent progress
  if (perf.mode === 0) { // QUALITY
    perf.targetFps = 60;
    perf.progressIntervalMs = 16;  // ~60fps IPC
    document.body.classList.remove('perf');
  } else if (perf.mode === 1) { // BALANCED
    perf.targetFps = 45;
    perf.progressIntervalMs = 22;  // ~45fps IPC
    document.body.classList.remove('perf');
  } else { // PERFORMANCE
    perf.targetFps = 30;
    perf.progressIntervalMs = 50;  // ~20fps IPC
    document.body.classList.add('perf');
  }

  perf.frameMs = 1000 / perf.targetFps;

  if (!isPrompter && perfBtn) {
    perfBtn.innerText = perfLabel(perf.mode);
    perfBtn.classList.remove('mode0', 'mode1', 'mode2');
    perfBtn.classList.add(perf.mode === 0 ? 'mode0' : perf.mode === 1 ? 'mode1' : 'mode2');
    perfBtn.title = perf.mode === 0 ? 'Максимальная плавность' :
                    perf.mode === 1 ? 'Компромисс' : 'Максимальная производительность';
  }

  if (shouldSync) {
    syncFull();
    saveStateDebounced();
  }
}

// ---- UI render ----
function updateUI(fastOnly = false) {
    if (cache.text !== state.text) { textDisplay.innerText = state.text; cache.text = state.text; needRecalc = true; }
    if (cache.fontSize !== state.fontSize) { textDisplay.style.fontSize = state.fontSize + 'px'; cache.fontSize = state.fontSize; needRecalc = true; }
    if (cache.width !== state.width) { textDisplay.style.width = state.width + '%'; cache.width = state.width; needRecalc = true; }

    if (needRecalc) recalcDistance();

    // NEW: render uses displayProgress (smoothed), fallback to state.progress
    const p = (typeof displayProgress === 'number') ? displayProgress : state.progress;
    const currentY = window.innerHeight - (p * distance);
    textDisplay.style.transform = `translate3d(0, ${currentY}px, 0)`;

    if (readingMarker) {
        readingMarker.style.display = state.markerEnabled ? 'block' : 'none';
    }

    if (isPrompter) {
        mirrorWrap.classList.toggle('mirror', !!state.mirror);
    }

    if (fastOnly) return;

    if (!isPrompter) {
        document.getElementById('speedVal').innerText = state.speed;
        document.getElementById('fontVal').innerText = state.fontSize;
        document.getElementById('widthVal').innerText = state.width + '%';

        startBtn.innerText = state.scrolling ? "ПАУЗА" : "СТАРТ";
        startBtn.classList.toggle('active', state.scrolling);
        mirrorBtn.classList.toggle('active', state.mirror);
        if (markerBtn) markerBtn.classList.toggle('active', state.markerEnabled);

        inputArea.disabled = state.scrolling;
        fontSlider.disabled = state.scrolling;
        widthSlider.disabled = state.scrolling;
        mirrorBtn.disabled = state.scrolling;
        openWindowBtn.disabled = state.scrolling;

        openWindowBtn.classList.toggle('active', prompterWindow && !prompterWindow.closed);
    }
}

// ---- IPC throttling ----
let lastProgressSent = 0;
function maybeSendProgress() {
    const now = performance.now();
    if (now - lastProgressSent < perf.progressIntervalMs) return;
    lastProgressSent = now;
    sendProgress(state.progress);
}

// ---- Animation ----
function animate(currentTime) {
    // FIX: FPS limiter should apply ONLY in PERF mode AND only for prompter window
    if (perf.mode === 2 && isPrompter) {
        if (currentTime - perf.lastFrame < perf.frameMs) {
            requestAnimationFrame(animate);
            return;
        }
        perf.lastFrame = currentTime;
    }

    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;

    if (state.scrolling) {
        smoothSpeed += (state.speed - smoothSpeed) * 0.08;
        state.progress += (smoothSpeed * deltaTime) * 0.000008;
        if (state.progress > 1) state.progress = 0;

        // NEW: interpolation for prompter smoothness
        // Controller follows itself; Prompter follows targetProgress from IPC.
        if (!isPrompter) targetProgress = state.progress;

        const alpha = (perf.mode === 0) ? 0.35 : (perf.mode === 1) ? 0.30 : 0.22;
        displayProgress += (targetProgress - displayProgress) * alpha;

        updateUI(true);
        maybeSendProgress();
    } else {
        smoothSpeed += (0 - smoothSpeed) * 0.08;

        // keep displayProgress stable when paused
        if (!isPrompter) {
            targetProgress = state.progress;
            displayProgress = state.progress;
        }
    }

    requestAnimationFrame(animate);
}

window.onunload = () => {
    if (prompterWindow) prompterWindow.close();
};

// ---- Controller window only ----
if (!isPrompter) {
    inputArea.value = state.text;
    speedSlider.value = state.speed;
    fontSlider.value = state.fontSize;
    widthSlider.value = state.width;

    document.getElementById('aboutBtn').onclick = () => { document.getElementById('aboutModal').style.display = 'flex'; clearFocus(); }
    document.getElementById('closeAboutBtn').onclick = () => { document.getElementById('aboutModal').style.display = 'none'; clearFocus(); }

    inputArea.oninput = () => {
        state.text = inputArea.value;
        syncFull();
        updateUI();
        saveStateDebounced();
    };

    [speedSlider, fontSlider, widthSlider].forEach(sl => {
        sl.oninput = () => {
            if (sl.disabled) return;
            state.speed = parseInt(speedSlider.value);
            state.fontSize = parseInt(fontSlider.value);
            state.width = parseInt(widthSlider.value);
            syncFull();
            updateUI();
            saveStateDebounced();
        };
    });

    perfBtn.onclick = () => {
        state.perfMode = (state.perfMode + 1) % 3;
        applyPerfMode(true);
        updateUI();
        clearFocus();
    };

    document.addEventListener('keydown', (e) => {
        if (document.activeElement === inputArea) return;

        if (e.code === 'Space') { e.preventDefault(); startBtn.click(); }
        if (e.code === 'KeyP') { e.preventDefault(); perfBtn.click(); }

        if (e.code === 'ArrowUp') { state.speed = Math.min(state.speed + 1, 40); speedSlider.value = state.speed; }
        if (e.code === 'ArrowDown') { state.speed = Math.max(state.speed - 1, 0); speedSlider.value = state.speed; }
        if (e.code === 'Home') { e.preventDefault(); state.progress = 0; }

        if (!state.scrolling) {
            if (e.code === 'ArrowRight') { state.fontSize = Math.min(state.fontSize + 2, 200); fontSlider.value = state.fontSize; }
            if (e.code === 'ArrowLeft') { state.fontSize = Math.max(state.fontSize - 2, 20); fontSlider.value = state.fontSize; }
            if (e.code === 'PageUp') { e.preventDefault(); state.width = Math.min(state.width + 5, 100); widthSlider.value = state.width; }
            if (e.code === 'PageDown') { e.preventDefault(); state.width = Math.max(state.width - 5, 20); widthSlider.value = state.width; }
        }

        syncFull();
        updateUI();
        saveStateDebounced();
    });

    window.addEventListener('wheel', (e) => {
        if (state.scrolling) return;
        state.progress = Math.max(0, Math.min(1, state.progress + e.deltaY * 0.0005));
        syncFull();
        updateUI();
        saveStateDebounced();
    }, { passive: true });

    startBtn.onclick = () => {
        state.scrolling = !state.scrolling;
        syncFull();
        updateUI();
        saveStateDebounced();
        clearFocus();
    };

    mirrorBtn.onclick = () => {
        if (state.scrolling) return;
        state.mirror = !state.mirror;
        syncFull();
        updateUI();
        saveStateDebounced();
        clearFocus();
    };

    markerBtn.onclick = () => {
        state.markerEnabled = !state.markerEnabled;
        syncFull();
        updateUI();
        saveStateDebounced();
        clearFocus();
    };

    openWindowBtn.onclick = () => {
        if (state.scrolling) return;

        if (prompterWindow && !prompterWindow.closed) {
            prompterWindow.close();
            prompterWindow = null;
        } else {
            const features = `width=${state.winW},height=${state.winH},left=${state.winX},top=${state.winY},menubar=no,toolbar=no,location=no,status=no`;
            prompterWindow = window.open(window.location.href.split('?')[0] + '?mode=prompter', 'Prompter', features);

            const saveGeom = () => {
                if (!prompterWindow || prompterWindow.closed) return;
                state.winX = prompterWindow.screenX;
                state.winY = prompterWindow.screenY;
                state.winW = prompterWindow.outerWidth;
                state.winH = prompterWindow.outerHeight;
                saveStateDebounced();
            };

            try {
                prompterWindow.addEventListener('beforeunload', saveGeom);
                prompterWindow.addEventListener('resize', saveGeom);
            } catch(_) {}

            const saveInterval = setInterval(() => {
                if (!prompterWindow || prompterWindow.closed) {
                    clearInterval(saveInterval);
                    updateUI();
                    return;
                }
                saveGeom();
            }, 500);

            channel.postMessage({ type: 'REQ' });
        }

        updateUI();
        clearFocus();
    };
} else {
    document.getElementById('controls').style.display = 'none';
    applyPerfMode(false);

    // ensure smoothing starts from current state after first SYNC
    targetProgress = state.progress;
    displayProgress = state.progress;

    channel.postMessage({ type: 'REQ' });
}

function showTab(tabId, btn) {
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(tabId).classList.add('active');
    btn.classList.add('active');
}

// init
applyPerfMode(false);
updateUI();
requestAnimationFrame(animate);
</script>
</body>
</html>
